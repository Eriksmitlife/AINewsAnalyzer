
import { storage } from '../storage';
import { aiService } from './aiService';
import type { InsertArticle, NewsSource } from '@shared/schema';

interface RSSItem {
  title: string;
  link: string;
  description?: string;
  pubDate?: string;
  author?: string;
  category?: string;
  content?: string;
}

interface AdContent {
  type: 'banner' | 'sponsored' | 'native';
  content: string;
  position: 'top' | 'middle' | 'bottom' | 'sidebar';
  targeting?: string[];
}

class NewsService {
  private isCollecting = false;
  private collectionInterval: NodeJS.Timeout | null = null;
  private errorCount = 0;
  private lastSuccessfulCollection = new Date();
  private readonly MAX_ERRORS_BEFORE_RESTART = 5;
  private readonly COLLECTION_INTERVAL = 5 * 60 * 1000; // 5 minutes for 24/7 operation

  async startNewsCollection(): Promise<void> {
    if (this.isCollecting) {
      console.log('News collection already in progress');
      return;
    }

    this.isCollecting = true;
    console.log('Starting 24/7 news collection...');

    try {
      await this.collectFromAllSources();
      this.errorCount = 0; // Reset error count on success
      this.lastSuccessfulCollection = new Date();
    } catch (error) {
      this.errorCount++;
      console.error(`Error in news collection (${this.errorCount}/${this.MAX_ERRORS_BEFORE_RESTART}):`, error);
      
      if (this.errorCount >= this.MAX_ERRORS_BEFORE_RESTART) {
        console.log('Too many errors, restarting collection system...');
        await this.restartCollectionSystem();
      }
    } finally {
      this.isCollecting = false;
    }
  }

  async scheduleNewsCollection(): Promise<void> {
    if (this.collectionInterval) {
      clearInterval(this.collectionInterval);
    }

    this.collectionInterval = setInterval(async () => {
      if (!this.isCollecting) {
        await this.startNewsCollection();
      }
    }, this.COLLECTION_INTERVAL);

    console.log(`24/7 News collection scheduled every ${this.COLLECTION_INTERVAL / 60000} minutes`);
    
    // Start health monitoring
    this.startHealthMonitoring();
  }

  private startHealthMonitoring(): void {
    setInterval(() => {
      const timeSinceLastSuccess = Date.now() - this.lastSuccessfulCollection.getTime();
      const maxAllowedGap = 30 * 60 * 1000; // 30 minutes
      
      if (timeSinceLastSuccess > maxAllowedGap) {
        console.warn('Health check failed: No successful collection in 30 minutes, restarting...');
        this.restartCollectionSystem();
      }
    }, 10 * 60 * 1000); // Check every 10 minutes
  }

  private async restartCollectionSystem(): Promise<void> {
    console.log('Restarting news collection system...');
    this.stopNewsCollection();
    this.errorCount = 0;
    
    // Wait 30 seconds before restart
    setTimeout(() => {
      this.scheduleNewsCollection();
    }, 30000);
  }

  private async collectFromAllSources(): Promise<void> {
    const sources = await storage.getNewsSources(true);
    console.log(`Collecting from ${sources.length} active news sources`);

    const collectionPromises = sources.map(source => 
      this.collectFromSourceWithRetry(source).catch(error => {
        console.error(`Failed to collect from ${source.name}:`, error);
        return [];
      })
    );

    const results = await Promise.all(collectionPromises);
    const totalArticles = results.reduce((sum, articles) => sum + articles.length, 0);
    
    console.log(`Collected ${totalArticles} new articles`);
    
    // Record collection metrics
    await aiService.recordMetric('news_collection_count', totalArticles, {
      sources: sources.length,
      timestamp: new Date().toISOString(),
      errorCount: this.errorCount,
    });

    // Generate ads for new articles
    if (totalArticles > 0) {
      await this.generateAdsForArticles(results.flat());
    }
  }

  private async collectFromSourceWithRetry(source: NewsSource, maxRetries = 3): Promise<any[]> {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await this.collectFromSource(source);
      } catch (error) {
        console.warn(`Attempt ${attempt}/${maxRetries} failed for ${source.name}:`, error);
        if (attempt === maxRetries) {
          // Mark source as problematic but don't throw
          await this.markSourceProblematic(source, error);
          return [];
        }
        // Wait before retry (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, attempt * 2000));
      }
    }
    return [];
  }

  private async markSourceProblematic(source: NewsSource, error: any): Promise<void> {
    try {
      await storage.updateNewsSource(source.id, {
        lastCrawled: new Date(),
        // Could add error tracking fields here
      });
      
      await aiService.recordMetric('source_error', 1, {
        sourceName: source.name,
        sourceId: source.id,
        error: error.message,
        timestamp: new Date().toISOString(),
      });
    } catch (logError) {
      console.error('Failed to mark source as problematic:', logError);
    }
  }

  private async collectFromSource(source: NewsSource): Promise<any[]> {
    try {
      let articles: RSSItem[] = [];
      
      if (source.rssUrl) {
        articles = await this.fetchFromRSS(source.rssUrl);
      } else {
        articles = await this.fetchFromWebsite(source.url);
      }

      const newArticles = [];
      
      for (const item of articles) {
        try {
          // Enhanced duplicate check
          const existingArticle = await this.checkIfArticleExistsEnhanced(item.link, item.title);
          if (existingArticle) continue;

          const articleData: InsertArticle = {
            title: this.cleanAndValidateTitle(item.title),
            content: this.enhanceContentWithAds(item.content || item.description || ''),
            summary: item.description || '',
            url: item.link,
            author: item.author || source.name,
            category: this.categorizeArticle(item.title, item.description || ''),
            sourceId: source.id,
            publishedAt: item.pubDate ? new Date(item.pubDate) : new Date(),
          };

          const article = await storage.createArticle(articleData);
          
          // Analyze article with AI (async, don't wait)
          this.analyzeArticleAsync(article);
          
          newArticles.push(article);
        } catch (error) {
          // Skip duplicate articles silently
          if (error instanceof Error && error.message.includes('duplicate key value violates unique constraint')) {
            continue;
          }
          console.error(`Error processing article "${item.title}":`, error);
        }
      }

      // Update source last crawled time
      await storage.updateNewsSource(source.id, {
        lastCrawled: new Date(),
      });

      return newArticles;
    } catch (error) {
      console.error(`Error collecting from source ${source.name}:`, error);
      throw error; // Re-throw for retry mechanism
    }
  }

  private cleanAndValidateTitle(title: string): string {
    const cleaned = this.cleanText(title);
    
    // Ensure title is not empty
    if (!cleaned.trim()) {
      return 'Untitled Article';
    }
    
    // Optimize title for maximum CTR
    const optimized = this.optimizeTitleForCTR(cleaned);
    
    // Ensure title is not too long but prioritize engagement
    if (optimized.length > 200) {
      return optimized.substring(0, 197) + '...';
    }
    
    return optimized;
  }

  private optimizeTitleForCTR(title: string): string {
    // Power words that increase CTR
    const powerWords = {
      urgency: ['–°–†–û–ß–ù–û', '–ú–û–õ–ù–ò–ï–ù–û–°–ù–û', '–ù–ï–ú–ï–î–õ–ï–ù–ù–û', '–°–ï–ô–ß–ê–°', '–°–ï–ì–û–î–ù–Ø'],
      curiosity: ['–°–ï–ö–†–ï–¢', '–¢–ê–ô–ù–ê', '–†–ê–°–ö–†–´–¢–û', '–û–ë–ù–ê–†–£–ñ–ï–ù–û', '–ù–ï–û–ñ–ò–î–ê–ù–ù–û'],
      benefit: ['–ë–ï–°–ü–õ–ê–¢–ù–û', '–≠–ö–°–ö–õ–Æ–ó–ò–í', '–£–ù–ò–ö–ê–õ–¨–ù–´–ô', '–†–ï–í–û–õ–Æ–¶–ò–û–ù–ù–´–ô', '–ü–†–û–†–´–í'],
      emotion: ['–®–û–ö–ò–†–£–Æ–©–ò–ô', '–ù–ï–í–ï–†–û–Ø–¢–ù–´–ô', '–£–î–ò–í–ò–¢–ï–õ–¨–ù–´–ô', '–°–ï–ù–°–ê–¶–ò–û–ù–ù–´–ô', '–ü–û–¢–†–Ø–°–ê–Æ–©–ò–ô'],
      social: ['–í–ò–†–£–°–ù–´–ô', '–¢–†–ï–ù–î–û–í–´–ô', '–ü–û–ü–£–õ–Ø–†–ù–´–ô', '–û–ë–°–£–ñ–î–ê–ï–ú–´–ô', '–•–ê–ô–ü–û–í–´–ô']
    };
    
    const numbers = ['5', '7', '10', '15', '20', '100'];
    const timeFrames = ['–∑–∞ 24 —á–∞—Å–∞', '–∑–∞ –Ω–µ–¥–µ–ª—é', '–∑–∞ –º–µ—Å—è—Ü', '–≤ 2024', '—Å–µ–≥–æ–¥–Ω—è'];
    
    let optimized = title;
    const lowerTitle = title.toLowerCase();
    
    // Add numbers for specificity (increases CTR by 36%)
    if (!/\d/.test(title) && Math.random() > 0.6) {
      const randomNumber = numbers[Math.floor(Math.random() * numbers.length)];
      const timeFrame = timeFrames[Math.floor(Math.random() * timeFrames.length)];
      
      if (lowerTitle.includes('—Å–ø–æ—Å–æ–±') || lowerTitle.includes('–º–µ—Ç–æ–¥')) {
        optimized = `${randomNumber} —Å–ø–æ—Å–æ–±–æ–≤ ${title.toLowerCase()}`;
      } else if (lowerTitle.includes('—Ñ–∞–∫—Ç') || lowerTitle.includes('–ø—Ä–∏—á–∏–Ω')) {
        optimized = `${randomNumber} —Ñ–∞–∫—Ç–æ–≤ –æ ${title.toLowerCase()}`;
      } else {
        optimized = `${title} (–¢–û–ü-${randomNumber} ${timeFrame})`;
      }
    }
    
    // Add power words if not present
    const hasPowerWord = Object.values(powerWords).flat().some(word => 
      lowerTitle.includes(word.toLowerCase())
    );
    
    if (!hasPowerWord && Math.random() > 0.5) {
      const categoryKeys = Object.keys(powerWords);
      const randomCategory = categoryKeys[Math.floor(Math.random() * categoryKeys.length)];
      const words = powerWords[randomCategory as keyof typeof powerWords];
      const randomWord = words[Math.floor(Math.random() * words.length)];
      
      optimized = `${randomWord}: ${optimized}`;
    }
    
    // Add emotional triggers
    const emotionalTriggers = [
      'üò±', 'üö®', '‚ö°', 'üî•', 'üí•', '‚≠ê', 'üéØ', 'üöÄ', 'üíé', 'üèÜ'
    ];
    
    if (!/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]/u.test(title) && Math.random() > 0.7) {
      const randomEmoji = emotionalTriggers[Math.floor(Math.random() * emotionalTriggers.length)];
      optimized = `${randomEmoji} ${optimized}`;
    }
    
    // Add trending elements
    const trendingElements = [
      '| –¢–†–ï–ù–î 2024',
      '| –í–ò–†–£–°–ù–û',
      '| –í–°–ï –û–ë–°–£–ñ–î–ê–Æ–¢',
      '| –•–ê–ô–ü',
      '| –ú–ï–ì–ê-–•–ò–¢'
    ];
    
    if (Math.random() > 0.8 && optimized.length < 150) {
      const randomElement = trendingElements[Math.floor(Math.random() * trendingElements.length)];
      optimized += ` ${randomElement}`;
    }
    
    // Capitalize important words for better readability
    optimized = this.capitalizeKeyWords(optimized);
    
    return optimized;
  }

  private capitalizeKeyWords(title: string): string {
    const importantWords = [
      'ai', '–Ω–∏–∏', 'crypto', 'bitcoin', 'ethereum', 'nft', 'blockchain',
      'tesla', 'apple', 'google', 'microsoft', 'amazon', 'meta',
      '—Ä–æ—Å—Å–∏—è', '—Å—à–∞', '–∫–∏—Ç–∞–π', '–µ–≤—Ä–æ–ø–∞', '—É–∫—Ä–∞–∏–Ω–∞'
    ];
    
    let result = title;
    importantWords.forEach(word => {
      const regex = new RegExp(`\\b${word}\\b`, 'gi');
      result = result.replace(regex, word.toUpperCase());
    });
    
    return result;
  }

  private enhanceContentWithAds(content: string): string {
    if (!content) return content;
    
    const ads = this.generateContextualAds(content);
    const optimizedContent = this.optimizeContentForTraffic(content);
    
    // Insert ads at strategic positions
    const paragraphs = optimizedContent.split('\n\n');
    if (paragraphs.length > 3) {
      // Insert native ad after first paragraph for better engagement
      paragraphs.splice(1, 0, ads.native);
      
      // Insert sponsored content in the middle
      const middleIndex = Math.floor(paragraphs.length / 2);
      paragraphs.splice(middleIndex, 0, ads.sponsored);
      
      // Insert banner ad at the end
      paragraphs.push(ads.banner);
      
      // Add sidebar ad for desktop users
      paragraphs.push(`\n<!-- SIDEBAR_AD -->${ads.sidebar}<!-- /SIDEBAR_AD -->`);
    }
    
    return paragraphs.join('\n\n');
  }

  private optimizeContentForTraffic(content: string): string {
    if (!content) return content;
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∏–≤–ª–µ–∫–∞—é—â–∏–µ –≤–Ω–∏–º–∞–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã
    let optimized = content;
    
    // –î–æ–±–∞–≤–ª—è–µ–º —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ç—Ä–∏–≥–≥–µ—Ä—ã
    const emotionalTriggers = [
      'üö® –í–ê–ñ–ù–û: ',
      '‚ö° –ú–û–õ–ù–ò–ï–ù–û–°–ù–û: ',
      'üî• –°–ï–ù–°–ê–¶–ò–Ø: ',
      'üí• –≠–ö–°–ö–õ–Æ–ó–ò–í: ',
      '‚≠ê –ü–†–û–†–´–í: ',
      'üéØ –¢–†–ï–ù–î: '
    ];
    
    // –°–ª—É—á–∞–π–Ω–æ –¥–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–∏–≥–≥–µ—Ä –≤ –Ω–∞—á–∞–ª–æ —Å—Ç–∞—Ç—å–∏
    if (Math.random() > 0.7) {
      const randomTrigger = emotionalTriggers[Math.floor(Math.random() * emotionalTriggers.length)];
      optimized = randomTrigger + optimized;
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    const interactiveElements = [
      '\nüí¨ –ß—Ç–æ –≤—ã –¥—É–º–∞–µ—Ç–µ –æ–± —ç—Ç–æ–º? –û—Å—Ç–∞–≤—å—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π!',
      '\nüìä –ì–æ–ª–æ—Å—É–π—Ç–µ: –ö–∞–∫ —ç—Ç–æ –ø–æ–≤–ª–∏—è–µ—Ç –Ω–∞ —Ä—ã–Ω–æ–∫?',
      '\nüîÑ –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —ç—Ç–æ–π –Ω–æ–≤–æ—Å—Ç—å—é —Å –¥—Ä—É–∑—å—è–º–∏!',
      '\n‚è∞ –°–ª–µ–¥–∏—Ç–µ –∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏!',
      '\nüéÅ –ü–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª –¥–ª—è —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã—Ö –Ω–æ–≤–æ—Å—Ç–µ–π!'
    ];
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∏–∑—ã–≤ –∫ –¥–µ–π—Å—Ç–≤–∏—é
    const randomCTA = interactiveElements[Math.floor(Math.random() * interactiveElements.length)];
    optimized += randomCTA;
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ —Ö–µ—à—Ç–µ–≥–∏
    const hashtags = this.generateTrendingHashtags(content);
    if (hashtags.length > 0) {
      optimized += '\n\n' + hashtags.join(' ');
    }
    
    return optimized;
  }

  private generateTrendingHashtags(content: string): string[] {
    const hashtags = new Set<string>();
    const lowerContent = content.toLowerCase();
    
    // –ö–∞—Ç–µ–≥–æ—Ä–∏–π–Ω—ã–µ —Ö–µ—à—Ç–µ–≥–∏
    const categoryHashtags = {
      'ai': ['#AI', '#ArtificialIntelligence', '#MachineLearning', '#TechNews', '#Innovation'],
      'crypto': ['#Crypto', '#Bitcoin', '#Blockchain', '#DeFi', '#Web3', '#NFT'],
      'startup': ['#Startup', '#Entrepreneur', '#Innovation', '#TechStartup', '#Funding'],
      'finance': ['#Finance', '#Investment', '#Trading', '#Markets', '#Economy'],
      'technology': ['#Tech', '#Technology', '#Digital', '#Innovation', '#Future'],
      'business': ['#Business', '#Corporate', '#Industry', '#Growth', '#Success']
    };
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ —Ö–µ—à—Ç–µ–≥–∏
    Object.entries(categoryHashtags).forEach(([keyword, tags]) => {
      if (lowerContent.includes(keyword)) {
        tags.slice(0, 3).forEach(tag => hashtags.add(tag));
      }
    });
    
    // –í—Å–µ–≥–¥–∞ –¥–æ–±–∞–≤–ª—è–µ–º –±—Ä–µ–Ω–¥–æ–≤—ã–µ —Ö–µ—à—Ç–µ–≥–∏
    hashtags.add('#AutoNewsAI');
    hashtags.add('#NewsAnalysis');
    hashtags.add('#BreakingNews');
    
    return Array.from(hashtags).slice(0, 8);
  }

  private generateContextualAds(content: string): { banner: string; native: string; sidebar: string; sponsored: string } {
    const lowerContent = content.toLowerCase();
    const currentTime = new Date();
    const isBusinessHours = currentTime.getHours() >= 9 && currentTime.getHours() <= 18;
    
    // AI/Tech-focused ads with traffic optimization
    if (lowerContent.includes('ai') || lowerContent.includes('technology') || lowerContent.includes('artificial intelligence')) {
      return {
        banner: '\n[AD] üöÄ –†–ï–í–û–õ–Æ–¶–ò–Ø: AI —Ä–µ—à–µ–Ω–∏—è —É–≤–µ–ª–∏—á–∏–≤–∞—é—Ç –ø—Ä–∏–±—ã–ª—å –Ω–∞ 300%! –ë–µ—Å–ø–ª–∞—Ç–Ω–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Å–µ–≥–æ–¥–Ω—è - TechSolutions.ai',
        native: '\nüí° –≠–ö–°–ö–õ–Æ–ó–ò–í: –°–µ–∫—Ä–µ—Ç–Ω—ã–µ AI —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –æ—Ç —Ç–æ–ø-–∫–æ–º–ø–∞–Ω–∏–π. –ö—É—Ä—Å "AI –¥–ª—è –±–∏–∑–Ω–µ—Å–∞" - 50% —Å–∫–∏–¥–∫–∞ —Ç–æ–ª—å–∫–æ 24 —á–∞—Å–∞! –ö–æ–¥: TECH50',
        sidebar: 'ü§ñ AI –ö–û–ù–°–£–õ–¨–¢–ê–¶–ò–Ø: –£–∑–Ω–∞–π—Ç–µ, –∫–∞–∫ AI –º–æ–∂–µ—Ç —É–¥–≤–æ–∏—Ç—å –≤–∞—à –¥–æ—Ö–æ–¥. –ë–µ—Å–ø–ª–∞—Ç–Ω—ã–π –∞—É–¥–∏—Ç –¥–ª—è –ø–µ—Ä–≤—ã—Ö 100 –∑–∞—è–≤–æ–∫!',
        sponsored: '\n[–°–ü–û–ù–°–û–†] üéØ Tesla –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —ç—Ç—É AI-—Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—é –¥–ª—è –∞–≤—Ç–æ–ø–∏–ª–æ—Ç–∞. –£–∑–Ω–∞–π—Ç–µ —Å–µ–∫—Ä–µ—Ç—ã –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–π –æ—Ç –∏–Ω–∂–µ–Ω–µ—Ä–æ–≤ Tesla!'
      };
    }
    
    // Crypto/Finance ads with urgency
    if (lowerContent.includes('crypto') || lowerContent.includes('bitcoin') || lowerContent.includes('finance') || lowerContent.includes('trading')) {
      return {
        banner: '\n[AD] üí∞ –í–ù–ò–ú–ê–ù–ò–ï: –ù–æ–≤–∞—è –∫—Ä–∏–ø—Ç–æ–±–∏—Ä–∂–∞ –¥–∞–µ—Ç 1000$ –±–æ–Ω—É—Å –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏! –¢–æ—Ä–≥—É–π—Ç–µ –ë–ï–ó –∫–æ–º–∏—Å—Å–∏–π - CryptoTrade.com',
        native: '\nüìà –°–ï–ö–†–ï–¢ –ú–ò–õ–õ–ò–û–ù–ï–†–û–í: –ö–∞–∫ –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å 100$ –≤ 10,000$ –∑–∞ –º–µ—Å—è—Ü. –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π –∫—É—Ä—Å –∫—Ä–∏–ø—Ç–æ—Ç—Ä–µ–π–¥–∏–Ω–≥–∞ - 80% —Å–∫–∏–¥–∫–∞!',
        sidebar: 'üíé CRYPTO –°–ò–ì–ù–ê–õ–´: +2847% –ø—Ä–∏–±—ã–ª—å –∑–∞ –≥–æ–¥! VIP-–∫–∞–Ω–∞–ª —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é 94%. –î–æ—Å—Ç—É–ø –∑–∞ 1$ –≤ –¥–µ–Ω—å!',
        sponsored: '\n[–ü–ê–†–¢–ù–ï–†] ‚ö° –ò–ª–æ–Ω –ú–∞—Å–∫ –∏–Ω–≤–µ—Å—Ç–∏—Ä—É–µ—Ç –≤ —ç—Ç—É –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—É. –£—Å–ø–µ–π—Ç–µ –∫—É–ø–∏—Ç—å –¥–æ –≤–∑–ª–µ—Ç–∞! –ü—Ä–æ–≥–Ω–æ–∑: +500%'
      };
    }
    
    // Startup/Business ads
    if (lowerContent.includes('startup') || lowerContent.includes('business') || lowerContent.includes('entrepreneur')) {
      return {
        banner: '\n[AD] üèÜ –°–¢–ê–†–¢–ê–ü-–ê–ö–°–ï–õ–ï–†–ê–¢–û–†: –û—Ç –∏–¥–µ–∏ –¥–æ $1M –∑–∞ 6 –º–µ—Å—è—Ü–µ–≤. –ü—Ä–∏–Ω–∏–º–∞–µ–º –∑–∞—è–≤–∫–∏ –¥–æ 31 —á–∏—Å–ª–∞!',
        native: '\nüöÄ CASE STUDY: –ö–∞–∫ —Å—Ç—É–¥–µ–Ω—Ç —Å–æ–∑–¥–∞–ª –µ–¥–∏–Ω–æ—Ä–æ–≥–∞ –∑–∞ 2 –≥–æ–¥–∞. –°–µ–∫—Ä–µ—Ç–Ω–∞—è —Ñ–æ—Ä–º—É–ª–∞ —É—Å–ø–µ—Ö–∞ - —Å–∫–∞—á–∞—Ç—å –±–µ—Å–ø–ª–∞—Ç–Ω–æ',
        sidebar: 'üíº –ò–ù–í–ï–°–¢–ò–¶–ò–ò: –¢–æ–ø VC –≥–æ—Ç–æ–≤—ã –∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ –≤–∞—à –ø—Ä–æ–µ–∫—Ç. –ü–∏—Ç—á-—Å–µ—Å—Å–∏—è –æ–Ω–ª–∞–π–Ω - —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∞',
        sponsored: '\n[–≠–ö–°–ö–õ–Æ–ó–ò–í] üéØ Y Combinator —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç —Å–µ–∫—Ä–µ—Ç—ã –æ—Ç–±–æ—Ä–∞ —Å—Ç–∞—Ä—Ç–∞–ø–æ–≤. –ß–µ–∫-–ª–∏—Å—Ç –¥–ª—è –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏—è!'
      };
    }
    
    // Health/Lifestyle ads
    if (lowerContent.includes('health') || lowerContent.includes('medical') || lowerContent.includes('lifestyle')) {
      return {
        banner: '\n[AD] üè• –ú–ï–î–ò–¶–ò–ù–°–ö–ò–ô –ü–†–û–†–´–í: –ù–æ–≤—ã–π –º–µ—Ç–æ–¥ –ª–µ—á–µ–Ω–∏—è –ø–æ–∫–∞–∑–∞–ª 95% —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å. –ö–ª–∏–Ω–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—ã—Ç–∞–Ω–∏—è!',
        native: '\nüíä –û–¢–ö–†–´–¢–ò–ï –í–ï–ö–ê: –ü—Ä–æ—Å—Ç–∞—è –¥–æ–±–∞–≤–∫–∞ –ø—Ä–æ–¥–ª–µ–≤–∞–µ—Ç –∂–∏–∑–Ω—å –Ω–∞ 20 –ª–µ—Ç. –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–π —à–æ–∫–∏—Ä—É—é—Ç!',
        sidebar: 'üß¨ –ì–ï–ù–ï–¢–ò–ß–ï–°–ö–ò–ô –¢–ï–°–¢: –£–∑–Ω–∞–π—Ç–µ –ø—Ä–µ–¥—Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å –∫ –±–æ–ª–µ–∑–Ω—è–º. –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω –∑–¥–æ—Ä–æ–≤—å—è –∑–∞ 24 —á–∞—Å–∞',
        sponsored: '\n[–ù–ê–£–ö–ê] üî¨ Harvard Medical School –ø—É–±–ª–∏–∫—É–µ—Ç —Ä–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω–æ–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –æ –¥–æ–ª–≥–æ–ª–µ—Ç–∏–∏'
      };
    }
    
    // Default high-converting ads with urgency
    const urgencyPhrases = [
      '–¢–û–õ–¨–ö–û –°–ï–ì–û–î–ù–Ø',
      '–ü–û–°–õ–ï–î–ù–ò–ô –î–ï–ù–¨',
      '–û–ì–†–ê–ù–ò–ß–ï–ù–ù–û–ï –ü–†–ï–î–õ–û–ñ–ï–ù–ò–ï',
      '–°–†–û–ß–ù–û',
      '–≠–ö–°–ö–õ–Æ–ó–ò–í',
      '–í–ù–ò–ú–ê–ù–ò–ï'
    ];
    
    const urgency = urgencyPhrases[Math.floor(Math.random() * urgencyPhrases.length)];
    
    return {
      banner: `\n[AD] üåü ${urgency}: AutoNews.AI PRO - AI –∞–Ω–∞–ª–∏–∑ –Ω–æ–≤–æ—Å—Ç–µ–π —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é 98%! –ü–æ–¥–ø–∏—Å–∫–∞ —Å–æ —Å–∫–∏–¥–∫–æ–π 70%`,
      native: '\nüì∞ –ò–ù–°–ê–ô–î–ï–†–°–ö–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø: –ù–æ–≤–æ—Å—Ç–∏, –∫–æ—Ç–æ—Ä—ã–µ –∏–∑–º–µ–Ω—è—Ç —Ä—ã–Ω–∫–∏ –∑–∞–≤—Ç—Ä–∞. VIP-–¥–æ—Å—Ç—É–ø –¥–ª—è –ø–µ—Ä–≤—ã—Ö 500 —á–µ–ª–æ–≤–µ–∫!',
      sidebar: `üéØ ${isBusinessHours ? '–ë–ò–ó–ù–ï–°-–í–û–ó–ú–û–ñ–ù–û–°–¢–¨' : '–ù–û–ß–ù–û–ï –ü–†–ï–î–õ–û–ñ–ï–ù–ò–ï'}: –ó–∞—Ä–∞–±–æ—Ç–∞–π—Ç–µ –Ω–∞ –Ω–æ–≤–æ—Å—Ç—è—Ö. –ü–∞—Å—Å–∏–≤–Ω—ã–π –¥–æ—Ö–æ–¥ –æ—Ç 5000‚ÇΩ/–¥–µ–Ω—å`,
      sponsored: '\n[–ü–ê–†–¢–ù–ï–†] üí• Forbes –Ω–∞–∑–≤–∞–ª —ç—Ç–æ "–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–µ–π –¥–µ—Å—è—Ç–∏–ª–µ—Ç–∏—è". –£–∑–Ω–∞–π—Ç–µ, –≤–æ —á—Ç–æ –∏–Ω–≤–µ—Å—Ç–∏—Ä—É—é—Ç –º–∏–ª–ª–∏–∞—Ä–¥–µ—Ä—ã!'
    };
  }

  private async checkIfArticleExistsEnhanced(url: string, title: string): Promise<boolean> {
    try {
      // Check by URL
      const articlesByUrl = await storage.getArticles({ limit: 1, search: url });
      if (articlesByUrl.some(article => article.url === url)) {
        return true;
      }
      
      // Check by similar title (prevent near-duplicates)
      const similarTitle = title.substring(0, 50);
      const articlesByTitle = await storage.getArticles({ limit: 5, search: similarTitle });
      return articlesByTitle.some(article => 
        this.calculateTitleSimilarity(article.title, title) > 0.8
      );
    } catch (error) {
      console.error('Error checking article existence:', error);
      return false;
    }
  }

  private calculateTitleSimilarity(title1: string, title2: string): number {
    const words1 = title1.toLowerCase().split(/\s+/);
    const words2 = title2.toLowerCase().split(/\s+/);
    
    const commonWords = words1.filter(word => words2.includes(word));
    const totalWords = new Set([...words1, ...words2]).size;
    
    return commonWords.length / totalWords;
  }

  private async fetchFromRSS(rssUrl: string): Promise<RSSItem[]> {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
      
      const response = await fetch(rssUrl, {
        headers: {
          'User-Agent': 'AutoNews.AI/2.0 (News Aggregator; +https://autonews.ai)',
          'Accept': 'application/rss+xml, application/xml, text/xml',
          'Cache-Control': 'no-cache',
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const xmlText = await response.text();
      const items = this.parseRSSXML(xmlText);
      
      return items.slice(0, 50); // Increased limit for 24/7 operation
    } catch (error) {
      console.error(`RSS fetch failed for ${rssUrl}:`, error);
      throw error; // Re-throw for retry mechanism
    }
  }

  private parseRSSXML(xmlText: string): RSSItem[] {
    const items: RSSItem[] = [];
    
    try {
      // Enhanced XML parsing for RSS items with better error handling
      const itemMatches = xmlText.match(/<item[^>]*>[\s\S]*?<\/item>/gi) || 
                         xmlText.match(/<entry[^>]*>[\s\S]*?<\/entry>/gi); // Support Atom feeds
      
      if (!itemMatches) {
        console.warn('No RSS items found in feed');
        return items;
      }

      for (const itemXml of itemMatches) {
        try {
          const title = this.extractXMLContent(itemXml, 'title');
          const link = this.extractXMLContent(itemXml, 'link') || 
                      this.extractXMLAttribute(itemXml, 'link', 'href'); // Support Atom links
          
          if (!title || !link) continue;

          const description = this.extractXMLContent(itemXml, 'description') ||
                            this.extractXMLContent(itemXml, 'summary');
          const pubDate = this.extractXMLContent(itemXml, 'pubDate') ||
                         this.extractXMLContent(itemXml, 'published') ||
                         this.extractXMLContent(itemXml, 'updated');
          const author = this.extractXMLContent(itemXml, 'author') || 
                        this.extractXMLContent(itemXml, 'dc:creator') ||
                        this.extractXMLContent(itemXml, 'name');
          const category = this.extractXMLContent(itemXml, 'category');
          const content = this.extractXMLContent(itemXml, 'content:encoded') ||
                         this.extractXMLContent(itemXml, 'content');

          items.push({
            title: this.cleanText(title),
            link: this.cleanText(link),
            description: description ? this.cleanText(description) : undefined,
            pubDate: pubDate ? this.cleanText(pubDate) : undefined,
            author: author ? this.cleanText(author) : undefined,
            category: category ? this.cleanText(category) : undefined,
            content: content ? this.cleanText(content) : undefined,
          });
        } catch (itemError) {
          console.warn('Error parsing RSS item:', itemError);
          continue; // Skip problematic items
        }
      }
    } catch (error) {
      console.error('RSS XML parsing error:', error);
      throw error;
    }

    return items;
  }

  private extractXMLContent(xml: string, tagName: string): string | null {
    const regex = new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)<\/${tagName}>`, 'i');
    const match = xml.match(regex);
    return match ? match[1].trim() : null;
  }

  private extractXMLAttribute(xml: string, tagName: string, attributeName: string): string | null {
    const regex = new RegExp(`<${tagName}[^>]*${attributeName}=["']([^"']*?)["'][^>]*>`, 'i');
    const match = xml.match(regex);
    return match ? match[1].trim() : null;
  }

  private cleanText(text: string): string {
    return text
      .replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1')
      .replace(/<[^>]+>/g, '')
      .replace(/&nbsp;/g, ' ')
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#039;/g, "'")
      .replace(/&#x27;/g, "'")
      .replace(/&apos;/g, "'")
      .replace(/\s+/g, ' ')
      .trim();
  }

  private async fetchFromWebsite(url: string): Promise<RSSItem[]> {
    console.log(`Direct website scraping not implemented for ${url}`);
    return [];
  }

  private categorizeArticle(title: string, description: string): string {
    const text = `${title} ${description}`.toLowerCase();
    
    const categories = {
      'AI & Technology': ['ai', 'artificial intelligence', 'machine learning', 'technology', 'tech', 'software', 'algorithm', 'neural', 'automation', '—Ä–æ–±–æ—Ç', '–∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç'],
      'Finance & Crypto': ['bitcoin', 'crypto', 'blockchain', 'finance', 'financial', 'investment', 'stock', 'market', 'trading', 'ethereum', '–±–∏—Ç–∫–æ–∏–Ω', '–∫—Ä–∏–ø—Ç–æ', '—Ñ–∏–Ω–∞–Ω—Å—ã'],
      'Startups': ['startup', 'entrepreneur', 'venture', 'funding', 'vc', 'investment round', 'seed', 'series a', '—Å—Ç–∞—Ä—Ç–∞–ø', '–ø—Ä–µ–¥–ø—Ä–∏–Ω–∏–º–∞—Ç–µ–ª—å'],
      'Science': ['science', 'research', 'study', 'discovery', 'scientific', 'experiment', 'breakthrough', '–Ω–∞—É–∫–∞', '–∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ'],
      'Business': ['business', 'company', 'corporate', 'enterprise', 'industry', 'ceo', 'economy', '–±–∏–∑–Ω–µ—Å', '–∫–æ–º–ø–∞–Ω–∏—è'],
      'Health': ['health', 'medical', 'healthcare', 'medicine', 'treatment', 'disease', 'therapy', '–∑–¥–æ—Ä–æ–≤—å–µ', '–º–µ–¥–∏—Ü–∏–Ω–∞'],
    };

    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.some(keyword => text.includes(keyword))) {
        return category;
      }
    }

    return 'General';
  }

  private async analyzeArticleAsync(article: any): Promise<void> {
    try {
      const analysis = await aiService.analyzeArticle(article);
      
      await storage.updateArticle(article.id, {
        sentiment: analysis.sentiment,
        sentimentScore: analysis.sentimentScore.toString(),
        factCheckScore: analysis.factCheckScore.toString(),
        trendingScore: analysis.trendingScore.toString(),
        isVerified: analysis.isVerified,
        summary: analysis.summary,
      });
    } catch (error) {
      console.error(`Error analyzing article ${article.id}:`, error);
    }
  }

  private async generateAdsForArticles(articles: any[]): Promise<void> {
    try {
      for (const article of articles) {
        const adContent = this.generateContextualAds(article.content || article.title);
        
        // Store ad metrics
        await aiService.recordMetric('ad_generated', 1, {
          articleId: article.id,
          adType: 'contextual',
          category: article.category,
          timestamp: new Date().toISOString(),
        });
      }
    } catch (error) {
      console.error('Error generating ads:', error);
    }
  }

  async initializeDefaultSources(): Promise<void> {
    const defaultSources = [
      {
        name: 'TechCrunch',
        url: 'https://techcrunch.com',
        rssUrl: 'https://techcrunch.com/feed/',
        category: 'AI & Technology',
        language: 'en',
      },
      {
        name: 'Hacker News',
        url: 'https://news.ycombinator.com',
        rssUrl: 'https://hnrss.org/frontpage',
        category: 'AI & Technology',
        language: 'en',
      },
      {
        name: 'MIT Technology Review',
        url: 'https://www.technologyreview.com',
        rssUrl: 'https://www.technologyreview.com/feed/',
        category: 'AI & Technology',
        language: 'en',
      },
      {
        name: 'VentureBeat',
        url: 'https://venturebeat.com',
        rssUrl: 'https://venturebeat.com/feed/',
        category: 'AI & Technology',
        language: 'en',
      },
      {
        name: 'CoinDesk',
        url: 'https://www.coindesk.com',
        rssUrl: 'https://www.coindesk.com/arc/outboundfeeds/rss/',
        category: 'Finance & Crypto',
        language: 'en',
      },
      {
        name: 'BBC Technology',
        url: 'https://www.bbc.com/news/technology',
        rssUrl: 'http://feeds.bbci.co.uk/news/technology/rss.xml',
        category: 'AI & Technology',
        language: 'en',
      },
      {
        name: 'Reuters Technology',
        url: 'https://www.reuters.com/technology/',
        rssUrl: 'https://www.reutersagency.com/feed/?best-topics=tech',
        category: 'AI & Technology',
        language: 'en',
      },
      // –î–æ–±–∞–≤–∏–º —Ä—É—Å—Å–∫–æ—è–∑—ã—á–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏
      {
        name: '–•–∞–±—Ä',
        url: 'https://habr.com',
        rssUrl: 'https://habr.com/rss/all/',
        category: 'AI & Technology',
        language: 'ru',
      },
      {
        name: 'RBC Tech',
        url: 'https://www.rbc.ru/technology_and_media/',
        rssUrl: 'https://rssexport.rbc.ru/rbcnews/news/30/full.rss',
        category: 'AI & Technology',
        language: 'ru',
      },
    ];

    for (const sourceData of defaultSources) {
      try {
        const existingSources = await storage.getNewsSources(false);
        const exists = existingSources.some(s => s.name === sourceData.name);
        
        if (!exists) {
          await storage.createNewsSource(sourceData);
          console.log(`Added news source: ${sourceData.name}`);
        }
      } catch (error) {
        console.error(`Error adding source ${sourceData.name}:`, error);
      }
    }
  }

  stopNewsCollection(): void {
    if (this.collectionInterval) {
      clearInterval(this.collectionInterval);
      this.collectionInterval = null;
    }
    console.log('News collection stopped');
  }

  // Health check endpoint
  getHealthStatus() {
    return {
      isCollecting: this.isCollecting,
      errorCount: this.errorCount,
      lastSuccessfulCollection: this.lastSuccessfulCollection,
      collectionInterval: this.COLLECTION_INTERVAL,
      maxErrors: this.MAX_ERRORS_BEFORE_RESTART,
    };
  }
}

export const newsService = new NewsService();

// Initialize default sources and start 24/7 collection
newsService.initializeDefaultSources().then(() => {
  newsService.scheduleNewsCollection();
  console.log('24/7 News collection system initialized successfully');
}).catch(error => {
  console.error('Failed to initialize news collection:', error);
  // Retry initialization after 60 seconds
  setTimeout(() => {
    newsService.initializeDefaultSources().then(() => {
      newsService.scheduleNewsCollection();
    });
  }, 60000);
});
